---
author: 勺夕
date: 2018-12-19 07:05:21
title: GC机制及优化    
tags:  
  - web
  - javascript
  - 前端
---
# GC机制及优化
javascript具有自动垃圾收集机制。即js的gc会按照固定的时间间隔（或者代码执行中预定的收集时间）周期性的进行找出那些不再继续使用的变量，释放内存。  

## 标记清除
javascript中最常用的垃圾收集方式是标记清除（mark-and-sweep）。  

> 在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间。  --摘自javascript高级程序设计  

## 引用计数  
不太常见的垃圾收集策略。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数+1。相反，如果包含这个值的变量又取得了另一个值时，引用次数-1。  
Netscape navigator3.0是最早使用引用计数的浏览器。但是遇到了循环引用，变量占用内存无法释放的情况。  
> 循环引用，如`a.b=b,b.a=a`  

其他，如IE的BOM和DOM中的对象，就是利用的C++的COM（组件对象模型）对象实现的，也是利用的引用计数策略。即使IE的JavaScript采用的是标记清除策略，当js访问COM对象时依然是引用计数。  
例如如下代码，会引发内存无法释放：  
```
var element = document.getElementById('abc');
var obj = new Object();
obj.e = element;
element.o = obj;
```
此时，即使移除对应DOM节点，也无法释放该部分内存。
> 此问题在IE9之后，BOM和DOM都被转换成了js对象，避免了上述问题。

## 优化方案
优化方案是建立在gc的策略基础上，就像是，你必须要在一条波涛汹涌的大江上行船时，就要考虑怎么顺着江水翻滚的规律造船和划桨一样。  

垃圾回收机制的策略如下：  
1. 周期性触发
2. 标记清除  

如IE7之前，会有写死的256个变量、4096个对象或数组字面量、或者64kb的字符串，如果超过，则会强制执行gc，这样导致不停的回收后，又不得不停申请内存，重大性能问题。 IE7之后，采用了根据内存分配量的百分比，来进行上限控制。  
其次，浏览器中可以通过js手动触发gc，如IE的`widow.CollectGarbage()`和Opera7+的`window.opera.collect()`,但是不建议这么做。  

优化总结：  
1. 尽量避免声明无用变量
2. 对使用完毕后，占用较大内存的变量，进行重新赋值为null，以释放其引用（解除引用）

## 案例  
有一个需求，需要我们导出很多数据的表格，生成excel。  
当生成10w条数据级别的excel时，会导致cpu飙高和gc较大波动。