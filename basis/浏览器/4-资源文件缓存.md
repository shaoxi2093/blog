网络访问、请求资源是一个非常消耗时间和其他网络资源的过程，在曾经的互联网时代，我还依然记得十几年前，一个没什么内容的网页加载都需要近一分钟（当然也有很大因素是网速），可见通过网络加载下来的服务器资源文件，是多么珍贵。因此也出了很多应对措施，去优化，web缓存就是其中之一。  
web缓存其实主要还是两处，一个就是将访问资源存放在浏览器本地缓存，还有一个就是存在其他代理服务器上。   

缓存主要可以解决或者说优化一些问题：  
1. 首先，一些静态资源的缓存，可以减少很多静态资源的网络数据传输，强缓存甚至能减少http请求的个数
2. 缓解带宽压力，无论是从客户端角度还是服务器角度
3. 缓解服务器对请求的响应和资源读取传输的处理压力
4. 像是cdn缓存降低了距离时延，同时也降低了对原始服务器的要求
5. 。。。
  

其实无论怎么说，它解决了的那些，目的都是为了，从资源访问下载过程优化，使用户能够更快的看到网站内容。  

## 缓存的问题  
缓存最大的问题，其实就是**怎么保证资源的‘新鲜度’**，如果不能保证资源是最新的，那么网站就和离线应用没什么差别了，失去了它本身快速更新的服务器端优势。  

## 浏览器缓存  
### 强缓存  
强缓存主要涉及到两个资源属性```Expires```和```Cache-Control```(优先级高于前者)。
Expires，是GMT格式的时间，表示资源的绝对有效期。
Cache-Control，字面意思，缓存控制。通常值有：
```
max-age  表示缓存的最长时间
no-cache 表示不缓存
no-store 表示禁止存储
public   表示所有用户可以缓存，包括代理服务器
private  表示只有终端用户（浏览器）可缓存
```  

其中要说明的，就是：  
1. no-cache说的是不缓存，其实意思是缓存，但是需要服务器确认是否有效，而no-store是真的不缓存
2. public和private的区别，public可以用于一些公用资源，private就是一些私有资源，如用户头像等等
3. 常用的不让强缓存，使用资源协商缓存的方式，就是将Expires设置为过去的某个时间，再将Cache-Control设置成no-cache  


### 协商缓存  
当Cache-Control:no-cache时，缓存进入协商缓存判断流程：  

ETag是一个不透明的标识符，由Web服务器根据URL上的资源的特定版本而指定。如果那个URL上的资源内容改变，一个新的不一样的ETag就会被分配。用这种方法使用ETag即类似于指纹，并且他们能够被快速地被比较，以确定两个版本的资源是否相同。ETag的比较只对同一个URL有意义——不同URL上的资源的ETag值可能相同也可能不同，从他们的ETag的比较中无从推断。--ETag维基百科

简单来说就是，ETag并不是根据文件更改时间去生成的，而是文件内容是否改动。它的出现就是为了解决之前版本的按照`Last-Modified`协商缓存的几个问题：  

1. 资源不经常改动，但是出现内容没变，修改时间改变了的情况
2. 资源经常改动，且改动出现在秒以下级别，`Last-Modified`只到秒级别
3. 服务器无法精确拿到文件改动时间的情况

协商缓存判断步骤如下：  

1. 首先判断资源是否有ETag，如果有，则发送资源请求时request header里中有	If-None-Match的之前缓存下来的资源ETag 服务器进行对比，确认资源是否更新，如果更新返回新的资源文件，否则返回304让浏览器继续使用缓存资源
2. 如果资源没有ETag，判断资源是否有Last-Modified，如果有，则发送资源请求时request header里中有If-Modified-Since，服务器进行判断浏览器之前缓存下来的资源在发送过去的时间后资源是否更新过，确认资源是否更新，如果更新返回新的资源文件，否则返回304让浏览器继续使用缓存资源，并更新资源的最新时间


### 补充

[以下内容摘自这里](https://www.cnblogs.com/slly/p/6732749.html)
> Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，**服务器会优先验证ETag**，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。  

## 使用强缓存实操问题

背景描述：chrome浏览器  
1. 希望对一个静态页面进行Expires强缓存，例如`https://www.baidu.com/example.html`，使用户访问时就直接走强缓存
2. 在服务端进行响应头中添加`Expires`或者`Cache-Control`
3. 使用浏览器对该链接访问，多次

问题发现：  
1. 多次访问时，仍然是200，并发起请求，但是响应头中的`Expires`或者`Cache-Control`展示正常
2. 用户第一次访问url时，请求头正常，但是按刷新后，**请求头**中包含`Cache-Control: max-age=0`即每次都会去服务器校验

查找资料：
1. [stackoverflow提问  http-expires-header-does-not-work-in-chrome](https://stackoverflow.com/questions/11559599/http-expires-header-does-not-work-in-chrome/11849014#11849014)
2. [how-to-avoid-a-browser-request-using-expires](https://stackoverflow.com/questions/20116571/how-to-avoid-a-browser-request-using-expires?noredirect=1&lq=1)


尝试汇总：  
1. chrome浏览器在的一个tab第一次访问【某个】url时，不会携带`Cache-Control: max-age=0`请求头，因此首先在tab1中访问该url，紧接着新开tab2可以直接走缓存，但是再次刷新页面时还是会重新发请求
2. Firefox点击刷新按钮时，会向服务器发起请求，但是在URL后直接回车不会向服务器发起请求，会直接走缓存
3. chrome和firefox都存在这种情况：在页面中添加一个`<a>`标签，href等于当前页面url，此时点击此标签时，页面刷新，但是会直接走缓存，而不会发起新请求。

---
> 你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：  
1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

