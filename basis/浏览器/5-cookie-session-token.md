# cookie、session、token

当用户访问服务器时，服务器要知道，并需要标记你是谁的时候，引出了session概念，再之后引入了token，解决多端登陆和减少服务器存储session等问题。当用户（浏览器）希望保持自己身份，和服务器之间持续沟通时，引出了cookie。  

## session  

服务器通过session机制来确定当前请求的用户，缘起于http是无状态协议。举个栗子，当访问一个购物网站时，点击加入购物车时，服务器不知道是谁加入的，确认是谁后，再点击下单告诉服务器时，服务器还要再去确认下这是谁下的单。因此服务器就会通过session去维护一个当前访问对象的一个信息。使你第一次访问和之后访问，服务器都知道你是谁。  

> Http协议是无状态的。（个人理解）就是没有上下文，当某一请求结束后则断开连接，下次请求会重新创建连接。就像是看不到来电显示的老式电话一样，收到来电，连接，说完话后，挂断电话。下次电话再响起来的时候，我还是不知道这次是谁打来的。  

当有许多个用户同时访问时，就会同时存在很多session，因此服务器会通过如内存、数据库、甚至静态文件去存储这个session列表。  

同时，session机制是双面的，即服务器维护了个session列表，但是请求来了，服务器需要确认这个请求是session池中的哪个。因此，整个流程就如下：  

1. 用户首次发起请求
2. 服务器(通过是否有sessionid，如果没有sessionid，证明是第一次访问，则创建)session维护起来，并给请求返回sessionid让用户保存，下次请求带上
3. 用户第二次请求
4. 服务器发现sessionid，然后去session池里找，是否存在这个用户，如果有，则承认用户，并继续利用这个身份会话，如果没有或者失效，则重新创建（如果是登陆鉴权失效，则需要重新登陆然后再创建）

### session存储

session需要两边同时存储，当然服务器端存储的内容会多一点，可以包括用户的一些基础数据，以减少对用户基础信息再次查询的负担，当然这里又牵扯到了数据冗余和同步问题，毕竟你redis缓存下来的接口数据，可能在你使用阶段，就已经在服务的别的入口已经改动过了，毕竟只是一个拷贝。这个先不去考虑。客户端（浏览器）主要存储一个sessionid就行。

- 服务端存储方案：redis，这不是绝对，你高兴存别的地方，文件、数据库、内存变量都行，只要你觉得适合就行。这里说到redis，后续我也要好好学习一下redis相关的内容，经常听到redis集群这种。之后在[这里学习和归纳](https://github.com/shaoxi2093/blog/tree/master/tools/redis)。  
- 客户端（浏览器）存储：cookie，当然这也不是绝对，毕竟有些时候浏览器可以禁止使用cookie。因此还可以通过其他存储，甚至url中存储。

## token

使用session后遇到的扩展问题：
当服务器需要扩展机器时，会引出负载均衡的概念（将请求按照服务资源等前置条件占比，均匀调配请求到不同服务器上响应），之后如果再对session进行服务端保存，有几种可预想的方案：  
1. 粘住请求 session sticky，将在A服务器上访问的请求，之后一直发给A去处理
2. 复制拷贝session，如A请求后创建session，在请求发到B时，去A的session管理中也进行查找
3. 综合1和2，其实需要一个统一的session管理，所有服务器均到此Session管理中去查询当前session

这些其实都会

## cookie  

cookie是浏览器针对网站的一个存储方式。
cookie也可以说是浏览器针对http协议做的一个优化，并不是http标准。当用户第二次请求同一网址下的服务时，会自动携带上发给服务器。这就是sessionid适合存储的地方。

## 当cookie被禁用后

当客户端禁用了Cookie之后，可以通过URL重写的方式进行实现。

可以通过`response.encodeURL(url)`进行实现，API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。
